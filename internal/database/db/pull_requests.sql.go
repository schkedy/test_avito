// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pull_requests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addReviewer = `-- name: AddReviewer :exec
INSERT INTO pr_reviewers (pull_request_id, reviewer_id, assigned_at)
VALUES ($1, $2, $3)
ON CONFLICT (pull_request_id, reviewer_id) DO NOTHING
`

type AddReviewerParams struct {
	PullRequestID string             `json:"pull_request_id"`
	ReviewerID    string             `json:"reviewer_id"`
	AssignedAt    pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) AddReviewer(ctx context.Context, arg AddReviewerParams) error {
	_, err := q.db.Exec(ctx, addReviewer, arg.PullRequestID, arg.ReviewerID, arg.AssignedAt)
	return err
}

const countPullRequests = `-- name: CountPullRequests :one
SELECT COUNT(*) FROM pull_requests
`

func (q *Queries) CountPullRequests(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPullRequests)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPullRequestsByStatus = `-- name: CountPullRequestsByStatus :one
SELECT COUNT(*) FROM pull_requests WHERE status = $1
`

func (q *Queries) CountPullRequestsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countPullRequestsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPullRequest = `-- name: CreatePullRequest :exec
INSERT INTO pull_requests (id, name, author_id, status, created_at, merged_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreatePullRequestParams struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	AuthorID  string             `json:"author_id"`
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	MergedAt  pgtype.Timestamptz `json:"merged_at"`
}

func (q *Queries) CreatePullRequest(ctx context.Context, arg CreatePullRequestParams) error {
	_, err := q.db.Exec(ctx, createPullRequest,
		arg.ID,
		arg.Name,
		arg.AuthorID,
		arg.Status,
		arg.CreatedAt,
		arg.MergedAt,
	)
	return err
}

const getPRsByReviewer = `-- name: GetPRsByReviewer :many
SELECT DISTINCT pr.id, pr.name, pr.author_id, pr.status, pr.created_at
FROM pull_requests pr
INNER JOIN pr_reviewers prr ON pr.id = prr.pull_request_id
WHERE prr.reviewer_id = $1
ORDER BY pr.created_at DESC
`

type GetPRsByReviewerRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	AuthorID  string             `json:"author_id"`
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPRsByReviewer(ctx context.Context, reviewerID string) ([]GetPRsByReviewerRow, error) {
	rows, err := q.db.Query(ctx, getPRsByReviewer, reviewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPRsByReviewerRow{}
	for rows.Next() {
		var i GetPRsByReviewerRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPullRequestByID = `-- name: GetPullRequestByID :one
SELECT id, name, author_id, status, created_at, merged_at
FROM pull_requests
WHERE id = $1
`

func (q *Queries) GetPullRequestByID(ctx context.Context, id string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPullRequestByID, id)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getReviewersByPRID = `-- name: GetReviewersByPRID :many
SELECT reviewer_id
FROM pr_reviewers
WHERE pull_request_id = $1
ORDER BY assigned_at
`

func (q *Queries) GetReviewersByPRID(ctx context.Context, pullRequestID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getReviewersByPRID, pullRequestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var reviewer_id string
		if err := rows.Scan(&reviewer_id); err != nil {
			return nil, err
		}
		items = append(items, reviewer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergePullRequest = `-- name: MergePullRequest :one
UPDATE pull_requests
SET status = 'MERGED', merged_at = $2
WHERE id = $1 AND status != 'MERGED'
RETURNING id, name, author_id, status, created_at, merged_at
`

type MergePullRequestParams struct {
	ID       string             `json:"id"`
	MergedAt pgtype.Timestamptz `json:"merged_at"`
}

func (q *Queries) MergePullRequest(ctx context.Context, arg MergePullRequestParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, mergePullRequest, arg.ID, arg.MergedAt)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const pullRequestExists = `-- name: PullRequestExists :one
SELECT EXISTS(SELECT 1 FROM pull_requests WHERE id = $1)
`

func (q *Queries) PullRequestExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, pullRequestExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeReviewer = `-- name: RemoveReviewer :exec
DELETE FROM pr_reviewers
WHERE pull_request_id = $1 AND reviewer_id = $2
`

type RemoveReviewerParams struct {
	PullRequestID string `json:"pull_request_id"`
	ReviewerID    string `json:"reviewer_id"`
}

func (q *Queries) RemoveReviewer(ctx context.Context, arg RemoveReviewerParams) error {
	_, err := q.db.Exec(ctx, removeReviewer, arg.PullRequestID, arg.ReviewerID)
	return err
}

const updatePullRequest = `-- name: UpdatePullRequest :exec
UPDATE pull_requests
SET name = $2, author_id = $3, status = $4, merged_at = $5
WHERE id = $1
`

type UpdatePullRequestParams struct {
	ID       string             `json:"id"`
	Name     string             `json:"name"`
	AuthorID string             `json:"author_id"`
	Status   string             `json:"status"`
	MergedAt pgtype.Timestamptz `json:"merged_at"`
}

func (q *Queries) UpdatePullRequest(ctx context.Context, arg UpdatePullRequestParams) error {
	_, err := q.db.Exec(ctx, updatePullRequest,
		arg.ID,
		arg.Name,
		arg.AuthorID,
		arg.Status,
		arg.MergedAt,
	)
	return err
}
