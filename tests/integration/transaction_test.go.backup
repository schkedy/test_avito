package integration

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"sync"
	"testing"
	"time"

	"test_avito/internal/domain"
	"test_avito/internal/repository"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test database connection string
const testDSN = "postgres://postgres:postgres@localhost:5434/postgres?sslmode=disable"

func setupTestDB(t *testing.T) (*pgxpool.Pool, func()) {
	t.Helper()

	pool, err := pgxpool.New(context.Background(), testDSN)
	require.NoError(t, err, "Failed to connect to test database")

	// Cleanup function
	cleanup := func() {
		cleanupTestData(t, pool)
		pool.Close()
	}

	return pool, cleanup
}

func cleanupTestData(t *testing.T, pool *pgxpool.Pool) {
	t.Helper()
	ctx := context.Background()

	// Delete in correct order due to foreign keys
	_, _ = pool.Exec(ctx, "DELETE FROM reviewers")
	_, _ = pool.Exec(ctx, "DELETE FROM pull_requests")
	_, _ = pool.Exec(ctx, "DELETE FROM users")
	_, _ = pool.Exec(ctx, "DELETE FROM teams")
}

func TestTeamCreateWithMembers_Success(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	team := &domain.Team{
		Name: "test-team-1",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
			{ID: "user2", Username: "bob", IsActive: true},
			{ID: "user3", Username: "charlie", IsActive: true},
		},
	}

	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Verify team and members were created
	createdTeam, err := repo.GetByName(context.Background(), "test-team-1")
	require.NoError(t, err)
	assert.Equal(t, "test-team-1", createdTeam.Name)
	assert.Len(t, createdTeam.Members, 3)
}

func TestTeamCreateWithMembers_Timeout(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// Create context with very short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()
	time.Sleep(10 * time.Millisecond) // Ensure timeout expires

	team := &domain.Team{
		Name: "test-team-timeout",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}

	err := repo.CreateWithMembers(ctx, team)
	assert.Error(t, err, "Expected timeout error")
	assert.Contains(t, err.Error(), "context")
}

func TestTeamCreateWithMembers_DuplicateTeam(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	team := &domain.Team{
		Name: "duplicate-team",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}

	// First creation should succeed
	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Second creation should fail due to unique constraint
	err = repo.CreateWithMembers(context.Background(), team)
	assert.Error(t, err, "Expected duplicate key error")
}

func TestTeamCreateWithMembers_RollbackOnError(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// First create a team to establish a duplicate scenario
	firstTeam := &domain.Team{
		Name: "test-team-rollback",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}
	err := repo.CreateWithMembers(context.Background(), firstTeam)
	require.NoError(t, err)

	// Try to create duplicate team - should fail on team creation
	// This will cause rollback, so members won't be inserted
	duplicateTeam := &domain.Team{
		Name: "test-team-rollback", // Same name - will violate unique constraint
		Members: []domain.User{
			{ID: "user2", Username: "bob", IsActive: true},
		},
	}

	err = repo.CreateWithMembers(context.Background(), duplicateTeam)
	assert.Error(t, err, "Expected error due to duplicate team")

	// Verify user2 was NOT created (transaction rolled back)
	createdTeam, err := repo.GetByName(context.Background(), "test-team-rollback")
	require.NoError(t, err)
	assert.Len(t, createdTeam.Members, 1)
	assert.Equal(t, "user1", createdTeam.Members[0].ID)
}

func TestTeamUpdateMembers_Success(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// Create team first
	team := &domain.Team{
		Name: "test-team-update",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}
	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Update members - UPSERT will add new members
	newMembers := []domain.User{
		{ID: "user2", Username: "bob", TeamName: "test-team-update", IsActive: true},
		{ID: "user3", Username: "charlie", TeamName: "test-team-update", IsActive: true},
	}
	err = repo.UpdateMembers(context.Background(), "test-team-update", newMembers)
	require.NoError(t, err)

	// Verify members were added (UPSERT adds, doesn't replace)
	updatedTeam, err := repo.GetByName(context.Background(), "test-team-update")
	require.NoError(t, err)
	assert.GreaterOrEqual(t, len(updatedTeam.Members), 2, "Should have at least 2 members")
}

func TestTeamUpdateMembers_ConcurrentUpdates(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// Create team
	team := &domain.Team{
		Name: "test-team-concurrent",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}
	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Run concurrent updates
	const numGoroutines = 10
	var wg sync.WaitGroup
	errors := make([]error, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()
			members := []domain.User{
				{ID: fmt.Sprintf("user%d", idx), Username: fmt.Sprintf("user%d", idx), IsActive: true},
			}
			errors[idx] = repo.UpdateMembers(context.Background(), "test-team-concurrent", members)
		}(i)
	}

	wg.Wait()

	// All updates should succeed (no deadlocks due to sorting)
	for i, err := range errors {
		assert.NoError(t, err, "Update %d failed", i)
	}
}

func TestPRCreate_Success(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with members
	team := &domain.Team{
		Name: "test-team-pr",
		Members: []domain.User{
			{ID: "author1", Username: "author", IsActive: true},
			{ID: "reviewer1", Username: "reviewer1", IsActive: true},
			{ID: "reviewer2", Username: "reviewer2", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PR with reviewers
	pr := &domain.PullRequest{
		ID:                "pr-1",
		Name:              "Test PR",
		AuthorID:          "author1",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{"reviewer1", "reviewer2"},
	}

	err = prRepo.Create(context.Background(), pr)
	require.NoError(t, err)

	// Verify PR was created
	createdPR, err := prRepo.GetByID(context.Background(), "pr-1")
	require.NoError(t, err)
	assert.Equal(t, "Test PR", createdPR.Name)
	assert.Len(t, createdPR.AssignedReviewers, 2)
}

func TestPRCreate_Timeout(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create context with very short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()
	time.Sleep(10 * time.Millisecond) // Ensure timeout expires

	pr := &domain.PullRequest{
		ID:                "pr-timeout",
		Name:              "Test PR",
		AuthorID:          "author1",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{"reviewer1"},
	}

	err := prRepo.Create(ctx, pr)
	assert.Error(t, err, "Expected timeout error")
}

func TestPRCreate_RollbackOnReviewerError(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with author
	team := &domain.Team{
		Name: "test-team-pr-rollback",
		Members: []domain.User{
			{ID: "author2", Username: "author", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Try to create PR with invalid reviewer (empty ID)
	pr := &domain.PullRequest{
		ID:                "pr-rollback",
		Name:              "Test PR",
		AuthorID:          "author2",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{""}, // Invalid empty reviewer ID
	}

	err = prRepo.Create(context.Background(), pr)
	assert.Error(t, err, "Expected error due to invalid reviewer")

	// Verify PR was NOT created (transaction rolled back)
	_, err = prRepo.GetByID(context.Background(), "pr-rollback")
	assert.Error(t, err)
	assert.ErrorIs(t, err, domain.ErrPRNotFound)
}

func TestPRCreate_DeadlockPrevention(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with reviewers
	team := &domain.Team{
		Name: "test-team-deadlock",
		Members: []domain.User{
			{ID: "author3", Username: "author", IsActive: true},
			{ID: "rev1", Username: "reviewer1", IsActive: true},
			{ID: "rev2", Username: "reviewer2", IsActive: true},
			{ID: "rev3", Username: "reviewer3", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PRs concurrently with different reviewer orders
	const numGoroutines = 10
	var wg sync.WaitGroup
	errors := make([]error, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()
			pr := &domain.PullRequest{
				ID:       fmt.Sprintf("pr-deadlock-%d", idx),
				Name:     fmt.Sprintf("Test PR %d", idx),
				AuthorID: "author3",
				Status:   domain.PRStatusOpen,
				// Different orders - but will be sorted internally
				AssignedReviewers: []string{"rev3", "rev1", "rev2"},
			}
			if idx%2 == 0 {
				pr.AssignedReviewers = []string{"rev2", "rev3", "rev1"}
			}
			errors[idx] = prRepo.Create(context.Background(), pr)
		}(i)
	}

	wg.Wait()

	// All creates should succeed (no deadlocks due to sorting)
	for i, err := range errors {
		assert.NoError(t, err, "Create %d failed", i)
	}
}

func TestPRMerge_Idempotent(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team and author
	team := &domain.Team{
		Name: "test-team-merge",
		Members: []domain.User{
			{ID: "author4", Username: "author", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PR
	pr := &domain.PullRequest{
		ID:                "pr-merge",
		Name:              "Test PR Merge",
		AuthorID:          "author4",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{},
	}
	err = prRepo.Create(context.Background(), pr)
	require.NoError(t, err)

	// Merge PR first time
	mergedPR1, err := prRepo.Merge(context.Background(), "pr-merge")
	require.NoError(t, err)
	assert.Equal(t, domain.PRStatusMerged, mergedPR1.Status)
	assert.NotNil(t, mergedPR1.MergedAt)

	// Merge PR second time (should be idempotent)
	mergedPR2, err := prRepo.Merge(context.Background(), "pr-merge")
	require.NoError(t, err)
	assert.Equal(t, domain.PRStatusMerged, mergedPR2.Status)
	assert.NotNil(t, mergedPR2.MergedAt)

	// Both should have the same merged timestamp (idempotent)
	assert.Equal(t, mergedPR1.MergedAt.Unix(), mergedPR2.MergedAt.Unix())
}

func TestPRMerge_NonExistent(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Try to merge non-existent PR
	_, err := prRepo.Merge(context.Background(), "non-existent-pr")
	assert.Error(t, err)
	assert.ErrorIs(t, err, domain.ErrPRNotFound)
}

func TestTransactionPanic_Recovery(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// This test verifies panic recovery is in place
	// We can't easily trigger a panic in production code without modifying it,
	// but we verify the transaction completes or rolls back correctly

	team := &domain.Team{
		Name: "test-team-panic",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}

	// Normal execution should work
	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Verify team was created
	createdTeam, err := repo.GetByName(context.Background(), "test-team-panic")
	require.NoError(t, err)
	assert.NotNil(t, createdTeam)
}

func TestTransactionCommit_ErrorHandling(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// Create team with valid data
	team := &domain.Team{
		Name: "test-team-commit",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
		},
	}

	err := repo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Verify transaction committed successfully
	createdTeam, err := repo.GetByName(context.Background(), "test-team-commit")
	require.NoError(t, err)
	assert.Equal(t, "test-team-commit", createdTeam.Name)
}

func TestConcurrentTransactions_Isolation(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	repo := repository.NewTeamRepository(pool, logger)

	// Create multiple teams concurrently
	const numTeams = 20
	var wg sync.WaitGroup
	errors := make([]error, numTeams)

	for i := 0; i < numTeams; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()
			team := &domain.Team{
				Name: fmt.Sprintf("test-team-isolation-%d", idx),
				Members: []domain.User{
					{ID: fmt.Sprintf("user%d", idx), Username: fmt.Sprintf("user%d", idx), IsActive: true},
				},
			}
			errors[idx] = repo.CreateWithMembers(context.Background(), team)
		}(i)
	}

	wg.Wait()

	// All creates should succeed
	successCount := 0
	for _, err := range errors {
		if err == nil {
			successCount++
		}
	}
	assert.Equal(t, numTeams, successCount, "All concurrent transactions should succeed")
}

func TestDeactivateTeamUsers_Success(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	userRepo := repository.NewUserRepository(pool, logger)

	// Create team with members
	team := &domain.Team{
		Name: "test-team-deactivate",
		Members: []domain.User{
			{ID: "user1", Username: "alice", IsActive: true},
			{ID: "user2", Username: "bob", IsActive: true},
			{ID: "user3", Username: "charlie", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Deactivate all team users
	count, err := userRepo.DeactivateTeamUsers(context.Background(), "test-team-deactivate")
	require.NoError(t, err)
	assert.Equal(t, 3, count)

	// Verify all users are deactivated
	updatedTeam, err := teamRepo.GetByName(context.Background(), "test-team-deactivate")
	require.NoError(t, err)
	for _, member := range updatedTeam.Members {
		assert.False(t, member.IsActive, "User %s should be deactivated", member.ID)
	}
}

func TestDeactivateTeamUsers_Timeout(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	userRepo := repository.NewUserRepository(pool, logger)

	// Create context with very short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()
	time.Sleep(10 * time.Millisecond) // Ensure timeout expires

	_, err := userRepo.DeactivateTeamUsers(ctx, "any-team")
	assert.Error(t, err, "Expected timeout error")
	assert.Contains(t, err.Error(), "context")
}

func TestDeactivateTeamUsers_EmptyTeam(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	userRepo := repository.NewUserRepository(pool, logger)

	// Create team without members
	team := &domain.Team{
		Name:    "test-team-empty",
		Members: []domain.User{},
	}
	err := teamRepo.Create(context.Background(), team)
	require.NoError(t, err)

	// Deactivate users in empty team
	count, err := userRepo.DeactivateTeamUsers(context.Background(), "test-team-empty")
	require.NoError(t, err)
	assert.Equal(t, 0, count, "Should deactivate 0 users")
}

func TestDeactivateTeamUsers_NonExistentTeam(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	userRepo := repository.NewUserRepository(pool, logger)

	// Deactivate users in non-existent team
	count, err := userRepo.DeactivateTeamUsers(context.Background(), "non-existent-team")
	require.NoError(t, err)
	assert.Equal(t, 0, count, "Should deactivate 0 users")
}

func TestReassignReviewer_Success(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with members
	team := &domain.Team{
		Name: "test-team-reassign",
		Members: []domain.User{
			{ID: "author", Username: "author", IsActive: true},
			{ID: "reviewer1", Username: "reviewer1", IsActive: true},
			{ID: "reviewer2", Username: "reviewer2", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PR with reviewer1
	pr := &domain.PullRequest{
		ID:                "pr-reassign",
		Name:              "Test PR",
		AuthorID:          "author",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{"reviewer1"},
	}
	err = prRepo.Create(context.Background(), pr)
	require.NoError(t, err)

	// Reassign from reviewer1 to reviewer2
	err = prRepo.ReassignReviewer(context.Background(), "pr-reassign", "reviewer1", "reviewer2")
	require.NoError(t, err)

	// Verify reassignment
	updatedPR, err := prRepo.GetByID(context.Background(), "pr-reassign")
	require.NoError(t, err)
	assert.Len(t, updatedPR.AssignedReviewers, 1)
	assert.Equal(t, "reviewer2", updatedPR.AssignedReviewers[0])
}

func TestReassignReviewer_Timeout(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create context with very short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()
	time.Sleep(10 * time.Millisecond) // Ensure timeout expires

	err := prRepo.ReassignReviewer(ctx, "pr-any", "old", "new")
	assert.Error(t, err, "Expected timeout error")
	assert.Contains(t, err.Error(), "context")
}

func TestReassignReviewer_RollbackOnError(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with members
	team := &domain.Team{
		Name: "test-team-reassign-rollback",
		Members: []domain.User{
			{ID: "author2", Username: "author", IsActive: true},
			{ID: "reviewer3", Username: "reviewer3", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PR with reviewer
	pr := &domain.PullRequest{
		ID:                "pr-reassign-rollback",
		Name:              "Test PR Rollback",
		AuthorID:          "author2",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{"reviewer3"},
	}
	err = prRepo.Create(context.Background(), pr)
	require.NoError(t, err)

	// Try to reassign to invalid reviewer (empty ID) - should fail and rollback
	err = prRepo.ReassignReviewer(context.Background(), "pr-reassign-rollback", "reviewer3", "")
	assert.Error(t, err, "Expected error due to invalid new reviewer")

	// Verify original reviewer is still assigned (transaction rolled back)
	unchangedPR, err := prRepo.GetByID(context.Background(), "pr-reassign-rollback")
	require.NoError(t, err)
	assert.Len(t, unchangedPR.AssignedReviewers, 1)
	assert.Equal(t, "reviewer3", unchangedPR.AssignedReviewers[0], "Original reviewer should still be assigned")
}

func TestReassignReviewer_ConcurrentReassignments(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with many reviewers
	members := []domain.User{
		{ID: "author3", Username: "author", IsActive: true},
	}
	for i := 1; i <= 10; i++ {
		members = append(members, domain.User{
			ID:       fmt.Sprintf("rev%d", i),
			Username: fmt.Sprintf("reviewer%d", i),
			IsActive: true,
		})
	}
	team := &domain.Team{
		Name:    "test-team-concurrent-reassign",
		Members: members,
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create multiple PRs with different reviewers
	const numPRs = 5
	for i := 0; i < numPRs; i++ {
		pr := &domain.PullRequest{
			ID:                fmt.Sprintf("pr-concurrent-reassign-%d", i),
			Name:              fmt.Sprintf("Test PR %d", i),
			AuthorID:          "author3",
			Status:            domain.PRStatusOpen,
			AssignedReviewers: []string{fmt.Sprintf("rev%d", i+1)},
		}
		err = prRepo.Create(context.Background(), pr)
		require.NoError(t, err)
	}

	// Concurrently reassign reviewers on different PRs
	var wg sync.WaitGroup
	errors := make([]error, numPRs)

	for i := 0; i < numPRs; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()
			prID := fmt.Sprintf("pr-concurrent-reassign-%d", idx)
			oldReviewer := fmt.Sprintf("rev%d", idx+1)
			newReviewer := fmt.Sprintf("rev%d", idx+6) // Different reviewer
			errors[idx] = prRepo.ReassignReviewer(context.Background(), prID, oldReviewer, newReviewer)
		}(i)
	}

	wg.Wait()

	// All reassignments should succeed (no race conditions)
	for i, err := range errors {
		assert.NoError(t, err, "Reassignment %d failed", i)
	}

	// Verify all reassignments were successful
	for i := 0; i < numPRs; i++ {
		pr, err := prRepo.GetByID(context.Background(), fmt.Sprintf("pr-concurrent-reassign-%d", i))
		require.NoError(t, err)
		expectedReviewer := fmt.Sprintf("rev%d", i+6)
		assert.Contains(t, pr.AssignedReviewers, expectedReviewer, "PR %d should have new reviewer", i)
	}
}

func TestReassignReviewer_AtomicOperation(t *testing.T) {
	pool, cleanup := setupTestDB(t)
	defer cleanup()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	teamRepo := repository.NewTeamRepository(pool, logger)
	prRepo := repository.NewPullRequestRepository(pool, logger)

	// Create team with members
	team := &domain.Team{
		Name: "test-team-atomic",
		Members: []domain.User{
			{ID: "author4", Username: "author", IsActive: true},
			{ID: "reviewer4", Username: "reviewer4", IsActive: true},
			{ID: "reviewer5", Username: "reviewer5", IsActive: true},
		},
	}
	err := teamRepo.CreateWithMembers(context.Background(), team)
	require.NoError(t, err)

	// Create PR
	pr := &domain.PullRequest{
		ID:                "pr-atomic",
		Name:              "Test Atomic",
		AuthorID:          "author4",
		Status:            domain.PRStatusOpen,
		AssignedReviewers: []string{"reviewer4"},
	}
	err = prRepo.Create(context.Background(), pr)
	require.NoError(t, err)

	// Reassign reviewer
	err = prRepo.ReassignReviewer(context.Background(), "pr-atomic", "reviewer4", "reviewer5")
	require.NoError(t, err)

	// Verify atomicity - exactly one reviewer, the new one
	finalPR, err := prRepo.GetByID(context.Background(), "pr-atomic")
	require.NoError(t, err)
	assert.Len(t, finalPR.AssignedReviewers, 1, "Should have exactly 1 reviewer")
	assert.Equal(t, "reviewer5", finalPR.AssignedReviewers[0], "Should be the new reviewer")

	// Verify old reviewer is completely removed
	assert.NotContains(t, finalPR.AssignedReviewers, "reviewer4", "Old reviewer should be removed")
}
